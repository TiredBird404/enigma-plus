# 中文简介
**Enigma+**，是基于第二次世界大战时期，纳粹德国所使用的密码机「恩尼格玛」改编而来的加密算法。该算法复刻了恩尼格玛机的字符转换与加密算法，并在**转子的生成**、**参数的无限制**与**字符库支援扩充**上作出衍生。  
  
***注：此程序仅为个人实验项目，无法与现代加密算法相比。***
## 算法逻辑
Enigma+的运算逻辑基于恩尼格玛机，其基本运行逻辑如下：
- ***循环*** 正序获取文本中第n个字符并进行转密：
  - ***判断*** 字符n若不在字符库中：转密下一个字符。
  - ***生成*** 字符n的转子序列与机械交换值。
  - ***交换*** 字符n与用户交换配置中所对应的字符。
  - ***循环*** 通过转子序列的转子r转换字符n，正序，循环至所有转子都已被调用处理：
    - ***获取*** 字符n在字符库中的位置，并将之加至当前转子所有的偏移值，最终获取偏移过后的字符。
    - ***寻找*** 偏移过后的字符在转子中所对应的字符位置l，并最终寻找位置l在字符库中所对应的字符。
  - ***交换*** 字符n与机械交换配置中所对应的字符。
  - ***循环*** 通过转子序列的转子r转换字符n，倒序，循环至所有转子都已被调用处理：
    - ***寻找*** 字符n在字符库中所对应的字符位置l，并最终寻找位置l在轮子r中所对应的字符c。
    - ***获取*** 字符c在字符库中的位置，并将之减至当前转子所有的偏移值，最终获取偏移过后的字符n。
  - ***交换*** 字符n与用户交换配置中所对应的字符。
  - ***转动*** 根据转动强度转动初始偏移第一格的数值，并进行后续的进位
- ***返回*** 循环中处理的字符的整合。
  
上述算法运行了原恩尼格玛机的逻辑，并加入了为每个字符都生成独自的转子一项，使其更加复杂。

## 字符库支援扩展
程序并未使用提前设定好的值来引用字符库，而是通过计算和循环等方式来进行调用，也因此，字符库理论上可以根据使用者需求在原始代码中进行修改或扩展。
唯一需要注意的是，因为字符机械转换的规则，因此字符库的长度不可为奇数，若配置错误程序会在启动时提示报错。

## 转子的生成
对于文本中的每一个字符，都会为其生成一整套转子，每个转子都是打乱字符库后产生的字符串。字符库的打乱基于**Fisher-Yates洗牌算法**，而洗牌算法中所用的换位随机值则为转为整数的**哈希值**（*基于SHA3-512算法*）。
每个哈希值的计算都基于经过处理的用户参数，因此，用户的参数对最终结果影响甚大，丝毫偏差便会使得输出结果大相径庭。单个转子的生成逻辑大致如下：
- ***设定*** 初始值 = 字符转换的整合 + 转为字符串(初始偏移的总合*一套轮子的数量+当前偏移值+转动强度+当前所生成转子的序列) -> 字符串
- ***重复*** 生成为给予字符库中所有字符的哈希值，正序重复字符库所有的字符数：
  - ***设定*** 计算值 = 初始值 + 转为字符串(初始值长度 * (初始值长度-当前次数序列))-> 字符串。
  - ***计算*** 计算值至哈希值，并将哈希值转为整数。
- ***获取*** 循环中计算的所有值并投入伪随机数组中。
- ***洗牌*** 通过Fisher-Yates洗牌算法，根据得来的伪随机数组，对字符库进行打乱。
- ***返回*** 洗牌结果

## 参数的无限制
在原版恩尼格玛机中，只可使用已有的3至4个转子，将其以可选的排序放入机器，最后为这3至4个转子设定初始偏移，而初始偏移的值也被局限为1至26（字符库的长度），最后转动幅度也仅为1步。
而在这个程序中，转子、偏移值、与转动强度理论上都可达至无限，这些值都与最终的生成密切相关，也大幅增加了暴力破解的难度。
同时，为了在让偏移值进位的同时也不会被取余限缩，在代码中编写了专门的进位算法，其逻辑如下：
- ***复制*** 偏移数组的值至另一个数组中。
- ***取余*** 将复制的数组的每个值取余，用于后续的进位计算。
- ***转动*** 根据转动强度转动偏移数组与复制数组的第一个值。
- ***重复*** 进行进位，正向重复(偏移数组的大小 - 1)的次数，循环次数以n表达：
  - ***增加*** 复制数组的第n个值除以字符库长度的整数化（去除小数点，作为进位数）至复制数组与偏移数组的第n+1个值。
- ***返回*** 进位后的偏移数组。
